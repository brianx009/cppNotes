#include<iostream>

using std::cout;
using std::endl;
using std::string;

//Example to show that our code will not compile if our reference is not set

// int main(){
//   int unitSales = 102;
//   int& unitSalesRef;     //requires an initializer

//   unitSalesRef = unitSales;
  
//   return 0;
// }

//Example to drive the point that with a reference, you will not be able to update the memory location of our reference. When we have the original reference on the lhs of the equal sign and a new variable on the rhs of the equal sign, it will not allocate a new memory location, instead it will use the same memory location and update the original variable it was referencing.

// int main(){

//   int unitSales = 102;     // int variable equal to 102
//   int& unitSalesRef = unitSales;     // referecnce to int variable

//   cout << "Original (unitSales): " << unitSales << endl;              // 102
//   cout << "Referecnce (unitSalesRef) : " << unitSalesRef << endl;     // 102

//   int moreUnitSales = 199;          // int variable equal to 199
//   unitSalesRef = moreUnitSales;     // using our reference of unitSales that  has the value 102, and updating it to hold the value 199
//                                     // note that doing this also updates unitSales to 199.
   
//   cout << "Original (unitSales): " << moreUnitSales << endl;         // 199
//   cout << "Referecnce (unitSalesRef) : " << unitSalesRef << endl;    // 199
//   cout << "Referecnce (unitSales) : " << unitSales << endl;          // 199  

  
//   return 0;
// }

// Example that uses different variable types instead of just int.
//Also note how clean it is working with references, here we see us creating a struct and accessing its member variables with the '.' notation. When using references we use '.' to access memnber variables/ functions and we are able to directly modify our references by calling their variable name. If we were using pointers we would have to use '->' and '*'.

struct Person{
  string name;
  
  Person(string n) : name(n){}     //constructor for person that also will set the "name" member variable
};


int main(){

  int unitSales = 102;     // int variable equal to 102
  int& unitSalesRef = unitSales;     // referecnce to int variable

  float gpa = 3.2f;
  float& gpaRef = gpa;
  
  string name = "Brian";
  string& nameRef = name;

  Person person("Brian");
  Person& personRef = person;

  //unitSales
  cout << "UnitSales (Orignal): " << unitSales << endl;
  cout << "UnitSalesRef (Original): " << unitSalesRef << endl;
  
  unitSalesRef++;
  
  cout << "UnitSales (Updated): " << unitSales << endl;
  cout << "UnitSalesRef (Updated): " << unitSalesRef << endl << endl;

  //gpa
  cout << "Gpa (Original): " << gpa << endl;
  cout << "GpaRef (Original): " << gpaRef << endl;
  
  gpa += 0.3;
  
  cout << "Gpa (Updated): " << gpa << endl;
  cout << "GpaRef (Updated)" << gpaRef << endl << endl;

  //name
  cout << "Name (Original): " << name << endl;
  cout << "NameRef (Original): " << nameRef << endl;
  
  name = "Brian Saldana";
  
  cout << "Name (Updated): " << name << endl;
  cout << "NameRed (Updated): " << nameRef << endl << endl;

  //person
  cout << "Person (Original): " << person.name << endl;
  cout << "PersonRef (Original): " << personRef.name << endl;
  
  person.name[0] = 'p';
  
  cout << "Person (Updated): " << person.name << endl;
  cout << "PersonRef (Updated): " << personRef.name << endl << endl;
  
  return 0;
}
